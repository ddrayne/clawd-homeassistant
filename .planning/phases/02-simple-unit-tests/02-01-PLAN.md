---
phase: 02-simple-unit-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_const.py
  - tests/test_exceptions.py
autonomous: true

must_haves:
  truths:
    - "All exception classes can be instantiated and carry expected error details"
    - "All constants in const.py have documented expected values"
    - "Exception hierarchy allows catching specific errors or base ClawdError"
  artifacts:
    - path: "tests/test_const.py"
      provides: "Constant value documentation tests"
      min_lines: 80
    - path: "tests/test_exceptions.py"
      provides: "Exception hierarchy and instantiation tests"
      min_lines: 60
  key_links:
    - from: "tests/test_const.py"
      to: "custom_components/clawd/const.py"
      via: "direct import"
      pattern: "from custom_components\\.clawd\\.const import"
    - from: "tests/test_exceptions.py"
      to: "custom_components/clawd/exceptions.py"
      via: "direct import"
      pattern: "from custom_components\\.clawd\\.exceptions import"
---

<objective>
Create unit tests for const.py constants and exceptions.py exception hierarchy.

Purpose: Document expected constant values through executable tests and verify exception classes work correctly for error handling throughout the codebase.

Output: Two test files (test_const.py, test_exceptions.py) that pass with pytest and serve as executable documentation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research
@.planning/phases/02-simple-unit-tests/02-RESEARCH.md

# Source files to test
@custom_components/clawd/const.py
@custom_components/clawd/exceptions.py

# Existing test infrastructure
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create constants tests</name>
  <files>tests/test_const.py</files>
  <action>
Create tests/test_const.py with comprehensive tests for all constants in const.py.

Structure the tests by logical groupings as shown in const.py:
1. TestDomain - Test DOMAIN is "clawd" (critical, must never change)
2. TestDefaultConfiguration - Test all DEFAULT_* values with both exact values AND validity checks (e.g., port in valid range)
3. TestConfigurationKeys - Test all CONF_* key strings
4. TestConnectionStates - Test all STATE_* values
5. TestProtocolVersion - Test MIN/MAX versions and relationship (MIN <= MAX)
6. TestClientIdentification - Test all CLIENT_* values

Use class-based test organization with descriptive test names. Each test should have a docstring explaining what is being documented.

Import all constants at module level:
```python
from custom_components.clawd.const import (
    DOMAIN,
    DEFAULT_HOST,
    DEFAULT_PORT,
    DEFAULT_USE_SSL,
    DEFAULT_TIMEOUT,
    DEFAULT_SESSION_KEY,
    DEFAULT_STRIP_EMOJIS,
    CONF_HOST,
    CONF_PORT,
    CONF_TOKEN,
    CONF_USE_SSL,
    CONF_TIMEOUT,
    CONF_SESSION_KEY,
    CONF_STRIP_EMOJIS,
    STATE_CONNECTED,
    STATE_DISCONNECTED,
    STATE_CONNECTING,
    STATE_ERROR,
    PROTOCOL_MIN_VERSION,
    PROTOCOL_MAX_VERSION,
    CLIENT_ID,
    CLIENT_DISPLAY_NAME,
    CLIENT_VERSION,
    CLIENT_PLATFORM,
    CLIENT_MODE,
)
```

These tests document expected values. If a constant value changes, the test failure alerts developers to update dependent code.
  </action>
  <verify>pytest tests/test_const.py -v shows all tests passing</verify>
  <done>All 22+ constants have tests documenting their expected values</done>
</task>

<task type="auto">
  <name>Task 2: Create exceptions tests</name>
  <files>tests/test_exceptions.py</files>
  <action>
Create tests/test_exceptions.py with tests for the exception hierarchy in exceptions.py.

Structure:
1. TestClawdErrorBase - Test base class inherits from Exception, can be instantiated with/without message
2. TestExceptionHierarchy - Use parametrize to test all 5 subclasses inherit from ClawdError
3. TestExceptionInstantiation - Use parametrize to test all exceptions can carry messages
4. TestExceptionRaiseAndCatch - Test that specific exceptions can be caught by ClawdError (important for error handling patterns)

Import all exceptions:
```python
from custom_components.clawd.exceptions import (
    ClawdError,
    GatewayConnectionError,
    GatewayAuthenticationError,
    GatewayTimeoutError,
    AgentExecutionError,
    ProtocolError,
)
```

Use pytest.mark.parametrize for testing multiple exception types with the same assertion pattern. Use ids parameter for readable test output.

Key test: Verify that raising GatewayConnectionError can be caught by `except ClawdError` - this is the error handling pattern used in conversation.py.
  </action>
  <verify>pytest tests/test_exceptions.py -v shows all tests passing</verify>
  <done>Exception hierarchy verified, all 6 exception classes can be instantiated and caught appropriately</done>
</task>

</tasks>

<verification>
1. Run: `pytest tests/test_const.py tests/test_exceptions.py -v`
   - All tests pass
2. Run: `pytest tests/test_const.py tests/test_exceptions.py --cov=custom_components.clawd.const --cov=custom_components.clawd.exceptions --cov-report=term-missing`
   - Coverage shows const.py and exceptions.py tested
</verification>

<success_criteria>
- test_const.py exists with tests for all constants
- test_exceptions.py exists with tests for exception hierarchy
- Both test files pass: `pytest tests/test_const.py tests/test_exceptions.py -v`
- Tests serve as executable documentation of expected values
- Requirements UNIT-01 and UNIT-02 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-simple-unit-tests/02-01-SUMMARY.md`
</output>
